Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EtchComponent = undefined;

var _etch = require('etch');

var _etch2 = _interopRequireDefault(_etch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
  Public: Abstract class for handling the initialization
  boilerplate of an Etch component.
*/
class EtchComponent {

  constructor(props) {
    this.props = props;

    _etch2.default.initialize(this);
    EtchComponent.setScheduler(atom.views);
  }

  /*
    Public: Gets the scheduler Etch uses for coordinating DOM updates.
     Returns a {Scheduler}
  */
  static getScheduler() {
    return _etch2.default.getScheduler();
  }

  /*
    Public: Sets the scheduler Etch uses for coordinating DOM updates.
     * `scheduler` {Scheduler}
  */
  static setScheduler(scheduler) {
    _etch2.default.setScheduler(scheduler);
  }

  /*
    Public: Updates the component's properties and re-renders it. Only the
    properties you specify in this object will update â€“ any other properties
    the component stores will be unaffected.
     * `props` an {Object} representing the properties you want to update
  */
  update(props = {}) {
    const oldProps = this.props;
    this.props = Object.assign({}, oldProps, props);
    return _etch2.default.update(this);
  }

  updateSync(props = {}) {
    const oldProps = this.props;
    this.props = Object.assign({}, oldProps, props);
    return _etch2.default.updateSync(this);
  }

  /*
    Public: Destroys the component, removing it from the DOM.
  */
  destroy(removeNode = false) {
    _etch2.default.destroy(this, removeNode);
  }

  render() {
    throw new Error('Etch components must implement a `render` method');
  }
}
exports.EtchComponent = EtchComponent;
/** @jsx etch.dom */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImV0Y2gtY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbIkV0Y2hDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiZXRjaCIsImluaXRpYWxpemUiLCJzZXRTY2hlZHVsZXIiLCJhdG9tIiwidmlld3MiLCJnZXRTY2hlZHVsZXIiLCJzY2hlZHVsZXIiLCJ1cGRhdGUiLCJvbGRQcm9wcyIsIk9iamVjdCIsImFzc2lnbiIsInVwZGF0ZVN5bmMiLCJkZXN0cm95IiwicmVtb3ZlTm9kZSIsInJlbmRlciIsIkVycm9yIl0sIm1hcHBpbmdzIjoiOzs7OztBQUdBOzs7Ozs7QUFNQTs7OztBQUlPLE1BQU1BLGFBQU4sQ0FBMEM7O0FBSy9DQyxjQUFZQyxLQUFaLEVBQTJCO0FBQ3pCLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjs7QUFFQUMsbUJBQUtDLFVBQUwsQ0FBZ0IsSUFBaEI7QUFDQUosa0JBQWNLLFlBQWQsQ0FBMkJDLEtBQUtDLEtBQWhDO0FBQ0Q7O0FBRUQ7Ozs7QUFLQSxTQUFPQyxZQUFQLEdBQXNCO0FBQ3BCLFdBQU9MLGVBQUtLLFlBQUwsRUFBUDtBQUNEOztBQUVEOzs7O0FBS0EsU0FBT0gsWUFBUCxDQUFvQkksU0FBcEIsRUFBb0M7QUFDbENOLG1CQUFLRSxZQUFMLENBQWtCSSxTQUFsQjtBQUNEOztBQUVEOzs7Ozs7QUFPQUMsU0FBT1IsUUFBYSxFQUFwQixFQUF3QjtBQUN0QixVQUFNUyxXQUFXLEtBQUtULEtBQXRCO0FBQ0EsU0FBS0EsS0FBTCxHQUFhVSxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQkYsUUFBbEIsRUFBNEJULEtBQTVCLENBQWI7QUFDQSxXQUFPQyxlQUFLTyxNQUFMLENBQVksSUFBWixDQUFQO0FBQ0Q7O0FBRURJLGFBQVdaLFFBQWEsRUFBeEIsRUFBNEI7QUFDMUIsVUFBTVMsV0FBVyxLQUFLVCxLQUF0QjtBQUNBLFNBQUtBLEtBQUwsR0FBYVUsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JGLFFBQWxCLEVBQTRCVCxLQUE1QixDQUFiO0FBQ0EsV0FBT0MsZUFBS1csVUFBTCxDQUFnQixJQUFoQixDQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBQyxVQUFRQyxhQUFzQixLQUE5QixFQUFxQztBQUNuQ2IsbUJBQUtZLE9BQUwsQ0FBYSxJQUFiLEVBQW1CQyxVQUFuQjtBQUNEOztBQUVEQyxXQUFTO0FBQ1AsVUFBTSxJQUFJQyxLQUFKLENBQVUsa0RBQVYsQ0FBTjtBQUNEO0FBMUQ4QztRQUFwQ2xCLGEsR0FBQUEsYTtBQVpiIiwiZmlsZSI6ImV0Y2gtY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Ii9ob21lL215dWdhLy5hdG9tL3BhY2thZ2VzL2dvLXBsdXMvbGliIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbi8qKiBAanN4IGV0Y2guZG9tICovXG5cbmltcG9ydCBldGNoIGZyb20gJ2V0Y2gnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyYWJsZSB7XG4gIHJlbmRlcigpOiBhbnk7XG59XG5cbi8qXG4gIFB1YmxpYzogQWJzdHJhY3QgY2xhc3MgZm9yIGhhbmRsaW5nIHRoZSBpbml0aWFsaXphdGlvblxuICBib2lsZXJwbGF0ZSBvZiBhbiBFdGNoIGNvbXBvbmVudC5cbiovXG5leHBvcnQgY2xhc3MgRXRjaENvbXBvbmVudCBpbXBsZW1lbnRzIFJlbmRlcmFibGUge1xuICBwcm9wczogYW55XG4gIHJlZnM6IE9iamVjdFxuICBlbGVtZW50OiBIVE1MRWxlbWVudFxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBPYmplY3QpIHtcbiAgICB0aGlzLnByb3BzID0gcHJvcHNcblxuICAgIGV0Y2guaW5pdGlhbGl6ZSh0aGlzKVxuICAgIEV0Y2hDb21wb25lbnQuc2V0U2NoZWR1bGVyKGF0b20udmlld3MpXG4gIH1cblxuICAvKlxuICAgIFB1YmxpYzogR2V0cyB0aGUgc2NoZWR1bGVyIEV0Y2ggdXNlcyBmb3IgY29vcmRpbmF0aW5nIERPTSB1cGRhdGVzLlxuXG4gICAgUmV0dXJucyBhIHtTY2hlZHVsZXJ9XG4gICovXG4gIHN0YXRpYyBnZXRTY2hlZHVsZXIoKSB7XG4gICAgcmV0dXJuIGV0Y2guZ2V0U2NoZWR1bGVyKClcbiAgfVxuXG4gIC8qXG4gICAgUHVibGljOiBTZXRzIHRoZSBzY2hlZHVsZXIgRXRjaCB1c2VzIGZvciBjb29yZGluYXRpbmcgRE9NIHVwZGF0ZXMuXG5cbiAgICAqIGBzY2hlZHVsZXJgIHtTY2hlZHVsZXJ9XG4gICovXG4gIHN0YXRpYyBzZXRTY2hlZHVsZXIoc2NoZWR1bGVyOiBhbnkpIHtcbiAgICBldGNoLnNldFNjaGVkdWxlcihzY2hlZHVsZXIpXG4gIH1cblxuICAvKlxuICAgIFB1YmxpYzogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgcHJvcGVydGllcyBhbmQgcmUtcmVuZGVycyBpdC4gT25seSB0aGVcbiAgICBwcm9wZXJ0aWVzIHlvdSBzcGVjaWZ5IGluIHRoaXMgb2JqZWN0IHdpbGwgdXBkYXRlIOKAkyBhbnkgb3RoZXIgcHJvcGVydGllc1xuICAgIHRoZSBjb21wb25lbnQgc3RvcmVzIHdpbGwgYmUgdW5hZmZlY3RlZC5cblxuICAgICogYHByb3BzYCBhbiB7T2JqZWN0fSByZXByZXNlbnRpbmcgdGhlIHByb3BlcnRpZXMgeW91IHdhbnQgdG8gdXBkYXRlXG4gICovXG4gIHVwZGF0ZShwcm9wczogYW55ID0ge30pIHtcbiAgICBjb25zdCBvbGRQcm9wcyA9IHRoaXMucHJvcHNcbiAgICB0aGlzLnByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgb2xkUHJvcHMsIHByb3BzKVxuICAgIHJldHVybiBldGNoLnVwZGF0ZSh0aGlzKVxuICB9XG5cbiAgdXBkYXRlU3luYyhwcm9wczogYW55ID0ge30pIHtcbiAgICBjb25zdCBvbGRQcm9wcyA9IHRoaXMucHJvcHNcbiAgICB0aGlzLnByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgb2xkUHJvcHMsIHByb3BzKVxuICAgIHJldHVybiBldGNoLnVwZGF0ZVN5bmModGhpcylcbiAgfVxuXG4gIC8qXG4gICAgUHVibGljOiBEZXN0cm95cyB0aGUgY29tcG9uZW50LCByZW1vdmluZyBpdCBmcm9tIHRoZSBET00uXG4gICovXG4gIGRlc3Ryb3kocmVtb3ZlTm9kZTogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgZXRjaC5kZXN0cm95KHRoaXMsIHJlbW92ZU5vZGUpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFdGNoIGNvbXBvbmVudHMgbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QnKVxuICB9XG59XG4iXX0=