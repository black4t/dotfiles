Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wantedPackage = wantedPackage;
exports.addImport = addImport;
exports.getPackage = getPackage;
exports.getRelativePackagePath = getRelativePackagePath;
exports.getCurrentGoWorkspaceFromGOPATH = getCurrentGoWorkspaceFromGOPATH;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const vendorString = '/vendor/';

function wantedPackage(buffer, pos) {
  // get the pkg the user tries to autocomplete from the current line
  const lineTillPos = buffer.getTextInRange([[pos.row, 0], pos]);
  const matches = lineTillPos.match(/(\w+)\.$/);
  if (!matches) {
    return null;
  }
  return matches[1];
}

function addImport(buffer, pkg, offset) {
  // find the "package ..." statement
  let row = -1;
  buffer.scan(/^package /, result => {
    row = result.row;
    if (row === undefined && result.range && result.range.start) {
      row = result.range.start.row;
    }
  });
  if (row === -1) {
    return null;
  }

  const text = buffer.getText();

  // import the "pkg" right after the package statement
  const importStmt = `import "${pkg}"\n`;
  const index = buffer.characterIndexForPosition([row + 1, 0]);
  const newText = text.substr(0, index) + importStmt + text.substr(index);
  const newOffset = offset + importStmt.length;
  return { text: newText, offset: newOffset };
}

function getPackage(file, gopath, pkgs, useVendor) {
  if (useVendor) {
    const dir = _path2.default.dirname(file);
    const workspace = getCurrentGoWorkspaceFromGOPATH(gopath, dir);
    const vendorPkgs = pkgs.filter(pkg => pkg.lastIndexOf(vendorString) > 0);
    for (const vpkg of vendorPkgs) {
      const relativePath = getRelativePackagePath(dir, workspace, vpkg);
      if (relativePath) {
        return relativePath;
      }
    }
  }

  // take the first non-vendor package
  return pkgs.find(pkg => pkg.lastIndexOf(vendorString) === -1);
}

function getRelativePackagePath(currentDir, currentWorkspace, pkg) {
  let magicVendorString = vendorString;
  let vendorIndex = pkg.lastIndexOf(magicVendorString);
  if (vendorIndex === -1) {
    magicVendorString = 'vendor/';
    if (pkg.startsWith(magicVendorString)) {
      vendorIndex = 0;
    }
  }
  // Check if current file and the vendor pkg belong to the same root project
  // If yes, then vendor pkg can be replaced with its relative path to the "vendor" folder
  // If not, then the vendor pkg should not be allowed to be imported.
  if (vendorIndex > -1) {
    let rootProjectForVendorPkg = _path2.default.join(currentWorkspace, pkg.substr(0, vendorIndex));
    let relativePathForVendorPkg = pkg.substring(vendorIndex + magicVendorString.length);

    if (relativePathForVendorPkg && currentDir.startsWith(rootProjectForVendorPkg)) {
      return relativePathForVendorPkg;
    }
    return '';
  }

  return pkg;
}

function getCurrentGoWorkspaceFromGOPATH(gopath, currentDir) {
  let workspaces = gopath.split(_path2.default.delimiter);
  let currentWorkspace = '';

  // Find current workspace by checking if current file is
  // under any of the workspaces in $GOPATH
  for (let i = 0; i < workspaces.length; i++) {
    let possibleCurrentWorkspace = _path2.default.join(workspaces[i], 'src');
    if (currentDir.startsWith(possibleCurrentWorkspace)) {
      // In case of nested workspaces, (example: both /Users/me and /Users/me/src/a/b/c are in $GOPATH)
      // both parent & child workspace in the nested workspaces pair can make it inside the above if block
      // Therefore, the below check will take longer (more specific to current file) of the two
      if (possibleCurrentWorkspace.length > currentWorkspace.length) {
        currentWorkspace = possibleCurrentWorkspace;
      }
    }
  }
  return currentWorkspace;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImdvY29kZXByb3ZpZGVyLWhlbHBlci5qcyJdLCJuYW1lcyI6WyJ3YW50ZWRQYWNrYWdlIiwiYWRkSW1wb3J0IiwiZ2V0UGFja2FnZSIsImdldFJlbGF0aXZlUGFja2FnZVBhdGgiLCJnZXRDdXJyZW50R29Xb3Jrc3BhY2VGcm9tR09QQVRIIiwidmVuZG9yU3RyaW5nIiwiYnVmZmVyIiwicG9zIiwibGluZVRpbGxQb3MiLCJnZXRUZXh0SW5SYW5nZSIsInJvdyIsIm1hdGNoZXMiLCJtYXRjaCIsInBrZyIsIm9mZnNldCIsInNjYW4iLCJyZXN1bHQiLCJ1bmRlZmluZWQiLCJyYW5nZSIsInN0YXJ0IiwidGV4dCIsImdldFRleHQiLCJpbXBvcnRTdG10IiwiaW5kZXgiLCJjaGFyYWN0ZXJJbmRleEZvclBvc2l0aW9uIiwibmV3VGV4dCIsInN1YnN0ciIsIm5ld09mZnNldCIsImxlbmd0aCIsImZpbGUiLCJnb3BhdGgiLCJwa2dzIiwidXNlVmVuZG9yIiwiZGlyIiwicGF0aCIsImRpcm5hbWUiLCJ3b3Jrc3BhY2UiLCJ2ZW5kb3JQa2dzIiwiZmlsdGVyIiwibGFzdEluZGV4T2YiLCJ2cGtnIiwicmVsYXRpdmVQYXRoIiwiZmluZCIsImN1cnJlbnREaXIiLCJjdXJyZW50V29ya3NwYWNlIiwibWFnaWNWZW5kb3JTdHJpbmciLCJ2ZW5kb3JJbmRleCIsInN0YXJ0c1dpdGgiLCJyb290UHJvamVjdEZvclZlbmRvclBrZyIsImpvaW4iLCJyZWxhdGl2ZVBhdGhGb3JWZW5kb3JQa2ciLCJzdWJzdHJpbmciLCJ3b3Jrc3BhY2VzIiwic3BsaXQiLCJkZWxpbWl0ZXIiLCJpIiwicG9zc2libGVDdXJyZW50V29ya3NwYWNlIl0sIm1hcHBpbmdzIjoiOzs7UUFNZ0JBLGEsR0FBQUEsYTtRQVVBQyxTLEdBQUFBLFM7UUEyQkFDLFUsR0FBQUEsVTtRQXNCQUMsc0IsR0FBQUEsc0I7UUFxQ0FDLCtCLEdBQUFBLCtCOztBQXBHaEI7Ozs7OztBQUVBLE1BQU1DLGVBQWUsVUFBckI7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MEJBQTBCZCxlQUFLZSxJQUFMLENBQzVCTCxnQkFENEIsRUFFNUIvQixJQUFJYSxNQUFKLENBQVcsQ0FBWCxFQUFjb0IsV0FBZCxDQUY0QixDQUE5QjtBQUlBLFFBQUlJLDJCQUEyQnJDLElBQUlzQyxTQUFKLENBQzdCTCxjQUFjRCxrQkFBa0JqQixNQURILENBQS9COztBQUlBLFFBQ0VzQiw0QkFDQVAsV0FBV0ksVUFBWCxDQUFzQkMsdUJBQXRCLENBRkYsRUFHRTtBQUNBLGFBQU9FLHdCQUFQO0FBQ0Q7QUFDRCxXQUFPLEVBQVA7QUFDRDs7QUFFRCxTQUFPckMsR0FBUDtBQUNEOztBQUVNLFNBQVNULCtCQUFULENBQ0wwQixNQURLLEVBRUxhLFVBRkssRUFHTDtBQUNBLE1BQUlTLGFBQWF0QixPQUFPdUIsS0FBUCxDQUFhbkIsZUFBS29CLFNBQWxCLENBQWpCO0FBQ0EsTUFBSVYsbUJBQW1CLEVBQXZCOztBQUVBO0FBQ0E7QUFDQSxPQUFLLElBQUlXLElBQUksQ0FBYixFQUFnQkEsSUFBSUgsV0FBV3hCLE1BQS9CLEVBQXVDMkIsR0FBdkMsRUFBNEM7QUFDMUMsUUFBSUMsMkJBQTJCdEIsZUFBS2UsSUFBTCxDQUFVRyxXQUFXRyxDQUFYLENBQVYsRUFBeUIsS0FBekIsQ0FBL0I7QUFDQSxRQUFJWixXQUFXSSxVQUFYLENBQXNCUyx3QkFBdEIsQ0FBSixFQUFxRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxVQUFJQSx5QkFBeUI1QixNQUF6QixHQUFrQ2dCLGlCQUFpQmhCLE1BQXZELEVBQStEO0FBQzdEZ0IsMkJBQW1CWSx3QkFBbkI7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxTQUFPWixnQkFBUDtBQUNEIiwiZmlsZSI6ImdvY29kZXByb3ZpZGVyLWhlbHBlci5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9teXVnYS8uYXRvbS9wYWNrYWdlcy9nby1wbHVzL2xpYi9hdXRvY29tcGxldGUiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuXG5jb25zdCB2ZW5kb3JTdHJpbmcgPSAnL3ZlbmRvci8nXG5cbmV4cG9ydCBmdW5jdGlvbiB3YW50ZWRQYWNrYWdlKGJ1ZmZlcjogYXRvbSRUZXh0QnVmZmVyLCBwb3M6IGF0b20kUG9pbnQpIHtcbiAgLy8gZ2V0IHRoZSBwa2cgdGhlIHVzZXIgdHJpZXMgdG8gYXV0b2NvbXBsZXRlIGZyb20gdGhlIGN1cnJlbnQgbGluZVxuICBjb25zdCBsaW5lVGlsbFBvcyA9IGJ1ZmZlci5nZXRUZXh0SW5SYW5nZShbW3Bvcy5yb3csIDBdLCBwb3NdKVxuICBjb25zdCBtYXRjaGVzID0gbGluZVRpbGxQb3MubWF0Y2goLyhcXHcrKVxcLiQvKVxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHJldHVybiBtYXRjaGVzWzFdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRJbXBvcnQoXG4gIGJ1ZmZlcjogYXRvbSRUZXh0QnVmZmVyLFxuICBwa2c6IHN0cmluZyxcbiAgb2Zmc2V0OiBudW1iZXJcbikge1xuICAvLyBmaW5kIHRoZSBcInBhY2thZ2UgLi4uXCIgc3RhdGVtZW50XG4gIGxldCByb3cgPSAtMVxuICBidWZmZXIuc2NhbigvXnBhY2thZ2UgLywgcmVzdWx0ID0+IHtcbiAgICByb3cgPSByZXN1bHQucm93XG4gICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkICYmIHJlc3VsdC5yYW5nZSAmJiByZXN1bHQucmFuZ2Uuc3RhcnQpIHtcbiAgICAgIHJvdyA9IHJlc3VsdC5yYW5nZS5zdGFydC5yb3dcbiAgICB9XG4gIH0pXG4gIGlmIChyb3cgPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHRleHQgPSBidWZmZXIuZ2V0VGV4dCgpXG5cbiAgLy8gaW1wb3J0IHRoZSBcInBrZ1wiIHJpZ2h0IGFmdGVyIHRoZSBwYWNrYWdlIHN0YXRlbWVudFxuICBjb25zdCBpbXBvcnRTdG10ID0gYGltcG9ydCBcIiR7cGtnfVwiXFxuYFxuICBjb25zdCBpbmRleCA9IGJ1ZmZlci5jaGFyYWN0ZXJJbmRleEZvclBvc2l0aW9uKFtyb3cgKyAxLCAwXSlcbiAgY29uc3QgbmV3VGV4dCA9IHRleHQuc3Vic3RyKDAsIGluZGV4KSArIGltcG9ydFN0bXQgKyB0ZXh0LnN1YnN0cihpbmRleClcbiAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgaW1wb3J0U3RtdC5sZW5ndGhcbiAgcmV0dXJuIHsgdGV4dDogbmV3VGV4dCwgb2Zmc2V0OiBuZXdPZmZzZXQgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFja2FnZShcbiAgZmlsZTogc3RyaW5nLFxuICBnb3BhdGg6IHN0cmluZyxcbiAgcGtnczogc3RyaW5nW10sXG4gIHVzZVZlbmRvcjogYm9vbGVhblxuKSB7XG4gIGlmICh1c2VWZW5kb3IpIHtcbiAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgICBjb25zdCB3b3Jrc3BhY2UgPSBnZXRDdXJyZW50R29Xb3Jrc3BhY2VGcm9tR09QQVRIKGdvcGF0aCwgZGlyKVxuICAgIGNvbnN0IHZlbmRvclBrZ3MgPSBwa2dzLmZpbHRlcihwa2cgPT4gcGtnLmxhc3RJbmRleE9mKHZlbmRvclN0cmluZykgPiAwKVxuICAgIGZvciAoY29uc3QgdnBrZyBvZiB2ZW5kb3JQa2dzKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBnZXRSZWxhdGl2ZVBhY2thZ2VQYXRoKGRpciwgd29ya3NwYWNlLCB2cGtnKVxuICAgICAgaWYgKHJlbGF0aXZlUGF0aCkge1xuICAgICAgICByZXR1cm4gcmVsYXRpdmVQYXRoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gdGFrZSB0aGUgZmlyc3Qgbm9uLXZlbmRvciBwYWNrYWdlXG4gIHJldHVybiBwa2dzLmZpbmQocGtnID0+IHBrZy5sYXN0SW5kZXhPZih2ZW5kb3JTdHJpbmcpID09PSAtMSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbGF0aXZlUGFja2FnZVBhdGgoXG4gIGN1cnJlbnREaXI6IHN0cmluZyxcbiAgY3VycmVudFdvcmtzcGFjZTogc3RyaW5nLFxuICBwa2c6IHN0cmluZ1xuKSB7XG4gIGxldCBtYWdpY1ZlbmRvclN0cmluZyA9IHZlbmRvclN0cmluZ1xuICBsZXQgdmVuZG9ySW5kZXggPSBwa2cubGFzdEluZGV4T2YobWFnaWNWZW5kb3JTdHJpbmcpXG4gIGlmICh2ZW5kb3JJbmRleCA9PT0gLTEpIHtcbiAgICBtYWdpY1ZlbmRvclN0cmluZyA9ICd2ZW5kb3IvJ1xuICAgIGlmIChwa2cuc3RhcnRzV2l0aChtYWdpY1ZlbmRvclN0cmluZykpIHtcbiAgICAgIHZlbmRvckluZGV4ID0gMFxuICAgIH1cbiAgfVxuICAvLyBDaGVjayBpZiBjdXJyZW50IGZpbGUgYW5kIHRoZSB2ZW5kb3IgcGtnIGJlbG9uZyB0byB0aGUgc2FtZSByb290IHByb2plY3RcbiAgLy8gSWYgeWVzLCB0aGVuIHZlbmRvciBwa2cgY2FuIGJlIHJlcGxhY2VkIHdpdGggaXRzIHJlbGF0aXZlIHBhdGggdG8gdGhlIFwidmVuZG9yXCIgZm9sZGVyXG4gIC8vIElmIG5vdCwgdGhlbiB0aGUgdmVuZG9yIHBrZyBzaG91bGQgbm90IGJlIGFsbG93ZWQgdG8gYmUgaW1wb3J0ZWQuXG4gIGlmICh2ZW5kb3JJbmRleCA+IC0xKSB7XG4gICAgbGV0IHJvb3RQcm9qZWN0Rm9yVmVuZG9yUGtnID0gcGF0aC5qb2luKFxuICAgICAgY3VycmVudFdvcmtzcGFjZSxcbiAgICAgIHBrZy5zdWJzdHIoMCwgdmVuZG9ySW5kZXgpXG4gICAgKVxuICAgIGxldCByZWxhdGl2ZVBhdGhGb3JWZW5kb3JQa2cgPSBwa2cuc3Vic3RyaW5nKFxuICAgICAgdmVuZG9ySW5kZXggKyBtYWdpY1ZlbmRvclN0cmluZy5sZW5ndGhcbiAgICApXG5cbiAgICBpZiAoXG4gICAgICByZWxhdGl2ZVBhdGhGb3JWZW5kb3JQa2cgJiZcbiAgICAgIGN1cnJlbnREaXIuc3RhcnRzV2l0aChyb290UHJvamVjdEZvclZlbmRvclBrZylcbiAgICApIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVBhdGhGb3JWZW5kb3JQa2dcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICByZXR1cm4gcGtnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50R29Xb3Jrc3BhY2VGcm9tR09QQVRIKFxuICBnb3BhdGg6IHN0cmluZyxcbiAgY3VycmVudERpcjogc3RyaW5nXG4pIHtcbiAgbGV0IHdvcmtzcGFjZXMgPSBnb3BhdGguc3BsaXQocGF0aC5kZWxpbWl0ZXIpXG4gIGxldCBjdXJyZW50V29ya3NwYWNlID0gJydcblxuICAvLyBGaW5kIGN1cnJlbnQgd29ya3NwYWNlIGJ5IGNoZWNraW5nIGlmIGN1cnJlbnQgZmlsZSBpc1xuICAvLyB1bmRlciBhbnkgb2YgdGhlIHdvcmtzcGFjZXMgaW4gJEdPUEFUSFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmtzcGFjZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcG9zc2libGVDdXJyZW50V29ya3NwYWNlID0gcGF0aC5qb2luKHdvcmtzcGFjZXNbaV0sICdzcmMnKVxuICAgIGlmIChjdXJyZW50RGlyLnN0YXJ0c1dpdGgocG9zc2libGVDdXJyZW50V29ya3NwYWNlKSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBuZXN0ZWQgd29ya3NwYWNlcywgKGV4YW1wbGU6IGJvdGggL1VzZXJzL21lIGFuZCAvVXNlcnMvbWUvc3JjL2EvYi9jIGFyZSBpbiAkR09QQVRIKVxuICAgICAgLy8gYm90aCBwYXJlbnQgJiBjaGlsZCB3b3Jrc3BhY2UgaW4gdGhlIG5lc3RlZCB3b3Jrc3BhY2VzIHBhaXIgY2FuIG1ha2UgaXQgaW5zaWRlIHRoZSBhYm92ZSBpZiBibG9ja1xuICAgICAgLy8gVGhlcmVmb3JlLCB0aGUgYmVsb3cgY2hlY2sgd2lsbCB0YWtlIGxvbmdlciAobW9yZSBzcGVjaWZpYyB0byBjdXJyZW50IGZpbGUpIG9mIHRoZSB0d29cbiAgICAgIGlmIChwb3NzaWJsZUN1cnJlbnRXb3Jrc3BhY2UubGVuZ3RoID4gY3VycmVudFdvcmtzcGFjZS5sZW5ndGgpIHtcbiAgICAgICAgY3VycmVudFdvcmtzcGFjZSA9IHBvc3NpYmxlQ3VycmVudFdvcmtzcGFjZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3VycmVudFdvcmtzcGFjZVxufVxuIl19