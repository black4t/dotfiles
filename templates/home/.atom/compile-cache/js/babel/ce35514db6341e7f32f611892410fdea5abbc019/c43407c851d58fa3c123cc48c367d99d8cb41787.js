Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.wantedPackage = wantedPackage;
exports.addImport = addImport;
exports.getPackage = getPackage;
exports.getRelativePackagePath = getRelativePackagePath;
exports.getCurrentGoWorkspaceFromGOPATH = getCurrentGoWorkspaceFromGOPATH;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var vendorString = '/vendor/';

function wantedPackage(buffer, pos) {
  // get the pkg the user tries to autocomplete from the current line
  var lineTillPos = buffer.getTextInRange([[pos.row, 0], pos]);
  var matches = lineTillPos.match(/(\w+)\.$/);
  if (!matches) {
    return null;
  }
  return matches[1];
}

function addImport(buffer, pkg, offset) {
  // find the "package ..." statement
  var row = -1;
  buffer.scan(/^package /, function (result) {
    row = result.row;
    if (row === undefined && result.range && result.range.start) {
      row = result.range.start.row;
    }
  });
  if (row === -1) {
    return null;
  }

  var text = buffer.getText();

  // import the "pkg" right after the package statement
  var importStmt = 'import "' + pkg + '"\n';
  var index = buffer.characterIndexForPosition([row + 1, 0]);
  var newText = text.substr(0, index) + importStmt + text.substr(index);
  var newOffset = offset + importStmt.length;
  return { text: newText, offset: newOffset };
}

function getPackage(file, gopath, pkgs, useVendor) {
  if (useVendor) {
    var dir = _path2['default'].dirname(file);
    var workspace = getCurrentGoWorkspaceFromGOPATH(gopath, dir);
    var vendorPkgs = pkgs.filter(function (pkg) {
      return pkg.lastIndexOf(vendorString) > 0;
    });
    for (var vpkg of vendorPkgs) {
      var relativePath = getRelativePackagePath(dir, workspace, vpkg);
      if (relativePath) {
        return relativePath;
      }
    }
  }

  // take the first non-vendor package
  return pkgs.find(function (pkg) {
    return pkg.lastIndexOf(vendorString) === -1;
  });
}

function getRelativePackagePath(currentDir, currentWorkspace, pkg) {
  var magicVendorString = vendorString;
  var vendorIndex = pkg.lastIndexOf(magicVendorString);
  if (vendorIndex === -1) {
    magicVendorString = 'vendor/';
    if (pkg.startsWith(magicVendorString)) {
      vendorIndex = 0;
    }
  }
  // Check if current file and the vendor pkg belong to the same root project
  // If yes, then vendor pkg can be replaced with its relative path to the "vendor" folder
  // If not, then the vendor pkg should not be allowed to be imported.
  if (vendorIndex > -1) {
    var rootProjectForVendorPkg = _path2['default'].join(currentWorkspace, pkg.substr(0, vendorIndex));
    var relativePathForVendorPkg = pkg.substring(vendorIndex + magicVendorString.length);

    if (relativePathForVendorPkg && currentDir.startsWith(rootProjectForVendorPkg)) {
      return relativePathForVendorPkg;
    }
    return '';
  }

  return pkg;
}

function getCurrentGoWorkspaceFromGOPATH(gopath, currentDir) {
  var workspaces = gopath.split(_path2['default'].delimiter);
  var currentWorkspace = '';

  // Find current workspace by checking if current file is
  // under any of the workspaces in $GOPATH
  for (var i = 0; i < workspaces.length; i++) {
    var possibleCurrentWorkspace = _path2['default'].join(workspaces[i], 'src');
    if (currentDir.startsWith(possibleCurrentWorkspace)) {
      // In case of nested workspaces, (example: both /Users/me and /Users/me/src/a/b/c are in $GOPATH)
      // both parent & child workspace in the nested workspaces pair can make it inside the above if block
      // Therefore, the below check will take longer (more specific to current file) of the two
      if (possibleCurrentWorkspace.length > currentWorkspace.length) {
        currentWorkspace = possibleCurrentWorkspace;
      }
    }
  }
  return currentWorkspace;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL215dWdhLy5hdG9tL3BhY2thZ2VzL2dvLXBsdXMvbGliL2F1dG9jb21wbGV0ZS9nb2NvZGVwcm92aWRlci1oZWxwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7b0JBRWlCLE1BQU07Ozs7QUFFdkIsSUFBTSxZQUFZLEdBQUcsVUFBVSxDQUFBOztBQUV4QixTQUFTLGFBQWEsQ0FBQyxNQUF1QixFQUFFLEdBQWUsRUFBRTs7QUFFdEUsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBQzlELE1BQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUE7QUFDN0MsTUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNaLFdBQU8sSUFBSSxDQUFBO0dBQ1o7QUFDRCxTQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQTtDQUNsQjs7QUFFTSxTQUFTLFNBQVMsQ0FDdkIsTUFBdUIsRUFDdkIsR0FBVyxFQUNYLE1BQWMsRUFDZDs7QUFFQSxNQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQTtBQUNaLFFBQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFVBQUEsTUFBTSxFQUFJO0FBQ2pDLE9BQUcsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFBO0FBQ2hCLFFBQUksR0FBRyxLQUFLLFNBQVMsSUFBSSxNQUFNLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFO0FBQzNELFNBQUcsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUE7S0FDN0I7R0FDRixDQUFDLENBQUE7QUFDRixNQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUNkLFdBQU8sSUFBSSxDQUFBO0dBQ1o7O0FBRUQsTUFBTSxJQUFJLEdBQUcsTUFB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QUFDLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQyxRQUFJLHdCQUF3QixHQUFHLGtCQUFLLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7QUFDOUQsUUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7Ozs7QUFJbkQsVUFBSSx3QkFBd0IsQ0FBQyxNQUFNLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxFQUFFO0FBQzdELHdCQUFnQixHQUFHLHdCQUF3QixDQUFBO09BQzVDO0tBQ0Y7R0FDRjtBQUNELFNBQU8sZ0JBQWdCLENBQUE7Q0FDeEIiLCJmaWxlIjoiL2hvbWUvbXl1Z2EvLmF0b20vcGFja2FnZXMvZ28tcGx1cy9saWIvYXV0b2NvbXBsZXRlL2dvY29kZXByb3ZpZGVyLWhlbHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5cbmNvbnN0IHZlbmRvclN0cmluZyA9ICcvdmVuZG9yLydcblxuZXhwb3J0IGZ1bmN0aW9uIHdhbnRlZFBhY2thZ2UoYnVmZmVyOiBhdG9tJFRleHRCdWZmZXIsIHBvczogYXRvbSRQb2ludCkge1xuICAvLyBnZXQgdGhlIHBrZyB0aGUgdXNlciB0cmllcyB0byBhdXRvY29tcGxldGUgZnJvbSB0aGUgY3VycmVudCBsaW5lXG4gIGNvbnN0IGxpbmVUaWxsUG9zID0gYnVmZmVyLmdldFRleHRJblJhbmdlKFtbcG9zLnJvdywgMF0sIHBvc10pXG4gIGNvbnN0IG1hdGNoZXMgPSBsaW5lVGlsbFBvcy5tYXRjaCgvKFxcdyspXFwuJC8pXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgcmV0dXJuIG1hdGNoZXNbMV1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEltcG9ydChcbiAgYnVmZmVyOiBhdG9tJFRleHRCdWZmZXIsXG4gIHBrZzogc3RyaW5nLFxuICBvZmZzZXQ6IG51bWJlclxuKSB7XG4gIC8vIGZpbmQgdGhlIFwicGFja2FnZSAuLi5cIiBzdGF0ZW1lbnRcbiAgbGV0IHJvdyA9IC0xXG4gIGJ1ZmZlci5zY2FuKC9ecGFja2FnZSAvLCByZXN1bHQgPT4ge1xuICAgIHJvdyA9IHJlc3VsdC5yb3dcbiAgICBpZiAocm93ID09PSB1bmRlZmluZWQgJiYgcmVzdWx0LnJhbmdlICYmIHJlc3VsdC5yYW5nZS5zdGFydCkge1xuICAgICAgcm93ID0gcmVzdWx0LnJhbmdlLnN0YXJ0LnJvd1xuICAgIH1cbiAgfSlcbiAgaWYgKHJvdyA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdGV4dCA9IGJ1ZmZlci5nZXRUZXh0KClcblxuICAvLyBpbXBvcnQgdGhlIFwicGtnXCIgcmlnaHQgYWZ0ZXIgdGhlIHBhY2thZ2Ugc3RhdGVtZW50XG4gIGNvbnN0IGltcG9ydFN0bXQgPSBgaW1wb3J0IFwiJHtwa2d9XCJcXG5gXG4gIGNvbnN0IGluZGV4ID0gYnVmZmVyLmNoYXJhY3RlckluZGV4Rm9yUG9zaXRpb24oW3JvdyArIDEsIDBdKVxuICBjb25zdCBuZXdUZXh0ID0gdGV4dC5zdWJzdHIoMCwgaW5kZXgpICsgaW1wb3J0U3RtdCArIHRleHQuc3Vic3RyKGluZGV4KVxuICBjb25zdCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBpbXBvcnRTdG10Lmxlbmd0aFxuICByZXR1cm4geyB0ZXh0OiBuZXdUZXh0LCBvZmZzZXQ6IG5ld09mZnNldCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWNrYWdlKFxuICBmaWxlOiBzdHJpbmcsXG4gIGdvcGF0aDogc3RyaW5nLFxuICBwa2dzOiBzdHJpbmdbXSxcbiAgdXNlVmVuZG9yOiBib29sZWFuXG4pIHtcbiAgaWYgKHVzZVZlbmRvcikge1xuICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICAgIGNvbnN0IHdvcmtzcGFjZSA9IGdldEN1cnJlbnRHb1dvcmtzcGFjZUZyb21HT1BBVEgoZ29wYXRoLCBkaXIpXG4gICAgY29uc3QgdmVuZG9yUGtncyA9IHBrZ3MuZmlsdGVyKHBrZyA9PiBwa2cubGFzdEluZGV4T2YodmVuZG9yU3RyaW5nKSA+IDApXG4gICAgZm9yIChjb25zdCB2cGtnIG9mIHZlbmRvclBrZ3MpIHtcbiAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGdldFJlbGF0aXZlUGFja2FnZVBhdGgoZGlyLCB3b3Jrc3BhY2UsIHZwa2cpXG4gICAgICBpZiAocmVsYXRpdmVQYXRoKSB7XG4gICAgICAgIHJldHVybiByZWxhdGl2ZVBhdGhcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyB0YWtlIHRoZSBmaXJzdCBub24tdmVuZG9yIHBhY2thZ2VcbiAgcmV0dXJuIHBrZ3MuZmluZChwa2cgPT4gcGtnLmxhc3RJbmRleE9mKHZlbmRvclN0cmluZykgPT09IC0xKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQYWNrYWdlUGF0aChcbiAgY3VycmVudERpcjogc3RyaW5nLFxuICBjdXJyZW50V29ya3NwYWNlOiBzdHJpbmcsXG4gIHBrZzogc3RyaW5nXG4pIHtcbiAgbGV0IG1hZ2ljVmVuZG9yU3RyaW5nID0gdmVuZG9yU3RyaW5nXG4gIGxldCB2ZW5kb3JJbmRleCA9IHBrZy5sYXN0SW5kZXhPZihtYWdpY1ZlbmRvclN0cmluZylcbiAgaWYgKHZlbmRvckluZGV4ID09PSAtMSkge1xuICAgIG1hZ2ljVmVuZG9yU3RyaW5nID0gJ3ZlbmRvci8nXG4gICAgaWYgKHBrZy5zdGFydHNXaXRoKG1hZ2ljVmVuZG9yU3RyaW5nKSkge1xuICAgICAgdmVuZG9ySW5kZXggPSAwXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGlmIGN1cnJlbnQgZmlsZSBhbmQgdGhlIHZlbmRvciBwa2cgYmVsb25nIHRvIHRoZSBzYW1lIHJvb3QgcHJvamVjdFxuICAvLyBJZiB5ZXMsIHRoZW4gdmVuZG9yIHBrZyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBpdHMgcmVsYXRpdmUgcGF0aCB0byB0aGUgXCJ2ZW5kb3JcIiBmb2xkZXJcbiAgLy8gSWYgbm90LCB0aGVuIHRoZSB2ZW5kb3IgcGtnIHNob3VsZCBub3QgYmUgYWxsb3dlZCB0byBiZSBpbXBvcnRlZC5cbiAgaWYgKHZlbmRvckluZGV4ID4gLTEpIHtcbiAgICBsZXQgcm9vdFByb2plY3RGb3JWZW5kb3JQa2cgPSBwYXRoLmpvaW4oXG4gICAgICBjdXJyZW50V29ya3NwYWNlLFxuICAgICAgcGtnLnN1YnN0cigwLCB2ZW5kb3JJbmRleClcbiAgICApXG4gICAgbGV0IHJlbGF0aXZlUGF0aEZvclZlbmRvclBrZyA9IHBrZy5zdWJzdHJpbmcoXG4gICAgICB2ZW5kb3JJbmRleCArIG1hZ2ljVmVuZG9yU3RyaW5nLmxlbmd0aFxuICAgIClcblxuICAgIGlmIChcbiAgICAgIHJlbGF0aXZlUGF0aEZvclZlbmRvclBrZyAmJlxuICAgICAgY3VycmVudERpci5zdGFydHNXaXRoKHJvb3RQcm9qZWN0Rm9yVmVuZG9yUGtnKVxuICAgICkge1xuICAgICAgcmV0dXJuIHJlbGF0aXZlUGF0aEZvclZlbmRvclBrZ1xuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHJldHVybiBwa2dcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRHb1dvcmtzcGFjZUZyb21HT1BBVEgoXG4gIGdvcGF0aDogc3RyaW5nLFxuICBjdXJyZW50RGlyOiBzdHJpbmdcbikge1xuICBsZXQgd29ya3NwYWNlcyA9IGdvcGF0aC5zcGxpdChwYXRoLmRlbGltaXRlcilcbiAgbGV0IGN1cnJlbnRXb3Jrc3BhY2UgPSAnJ1xuXG4gIC8vIEZpbmQgY3VycmVudCB3b3Jrc3BhY2UgYnkgY2hlY2tpbmcgaWYgY3VycmVudCBmaWxlIGlzXG4gIC8vIHVuZGVyIGFueSBvZiB0aGUgd29ya3NwYWNlcyBpbiAkR09QQVRIXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya3NwYWNlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwb3NzaWJsZUN1cnJlbnRXb3Jrc3BhY2UgPSBwYXRoLmpvaW4od29ya3NwYWNlc1tpXSwgJ3NyYycpXG4gICAgaWYgKGN1cnJlbnREaXIuc3RhcnRzV2l0aChwb3NzaWJsZUN1cnJlbnRXb3Jrc3BhY2UpKSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIG5lc3RlZCB3b3Jrc3BhY2VzLCAoZXhhbXBsZTogYm90aCAvVXNlcnMvbWUgYW5kIC9Vc2Vycy9tZS9zcmMvYS9iL2MgYXJlIGluICRHT1BBVEgpXG4gICAgICAvLyBib3RoIHBhcmVudCAmIGNoaWxkIHdvcmtzcGFjZSBpbiB0aGUgbmVzdGVkIHdvcmtzcGFjZXMgcGFpciBjYW4gbWFrZSBpdCBpbnNpZGUgdGhlIGFib3ZlIGlmIGJsb2NrXG4gICAgICAvLyBUaGVyZWZvcmUsIHRoZSBiZWxvdyBjaGVjayB3aWxsIHRha2UgbG9uZ2VyIChtb3JlIHNwZWNpZmljIHRvIGN1cnJlbnQgZmlsZSkgb2YgdGhlIHR3b1xuICAgICAgaWYgKHBvc3NpYmxlQ3VycmVudFdvcmtzcGFjZS5sZW5ndGggPiBjdXJyZW50V29ya3NwYWNlLmxlbmd0aCkge1xuICAgICAgICBjdXJyZW50V29ya3NwYWNlID0gcG9zc2libGVDdXJyZW50V29ya3NwYWNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjdXJyZW50V29ya3NwYWNlXG59XG4iXX0=